% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wglmm_R_paket.R
\name{wglmm}
\alias{wglmm}
\title{Modularized Survey-weighted Generalized Linear Mixed Models}
\usage{
wglmm(formula, data = NULL, family = gaussian(), weights = NULL,
  iter1  = 501, iter2 = 501,  MI = 500, tol1 = 2e-4,
  tol2 = 1e-5, trace = TRUE, nDecrease = 2, ...)
}
\arguments{
\item{formula}{Formula for the Model to be estimated. Has the shape of lmer in the package lme4.}

\item{data}{Dataframe containing the variables}

\item{family}{Distribution from the exponential family. You can choose between gaussian(), binomial(),  poisson(),  Gamma() and  exponential(). However, only  gaussian() and binomial() are already extensively tested.}

\item{weights}{Survey weights}

\item{e_step_method}{Method for the E-Step ("e_step_importance_sampling" or "e_step_gibbs_sampling").}

\item{m_step_method}{Method for the M-Step ("m_step_gradient_descent" or "m_step_bfgs").}

\item{iter1}{Maximum number of MCEM iterations}

\item{iter2}{Maximum number of internal optimizations within a MCEM-step}

\item{MI}{Number of importance-sampled random numbers in E-step}

\item{tol1}{Convergence criterion for MCEM algorithm}

\item{tol2}{Convergence criterion for optimizations within a MCEM-step}

\item{...}{Additional options for model set-up}
}
\value{
A list with the following elements
\itemize{
\item coef Vector of fixed effects regression parameters
\item VarCov List of random effects variance-covariance matrices
\item scale Scale parameter for exponential family
\item RE_mat Matrix with simulated random effects from last E-step, including importance weights
\item RE_mode List with modes of the random effects
\item residuals List with different types of residuals
\item LLmod Joint maximum log-likelihood of observed data and the mode of random effects
\item LLexp Expected log-likelihood given the observed data
\item niter Number of iterations
\item convergence Has MCEM converged?
} or
\itemize{
\item DIC Deviance Information Criterion, a measure of model fit.
\item fixed.formula Formula for the fixed effects in the model.
\item random.formula Formula for the random effects in the model.
\item residual.formula Formula for the residual variance structure.
\item solutions Posterior means, confidence intervals, and effective sample sizes for the fixed effects.
\item Gcovariances Posterior means, confidence intervals, and effective sample sizes for the random effect covariances.
\item Gterms Joint Posterior modes and confidence intervals for the variance-covariance parameters of the random effects.
\item Rcovariances Posterior means, confidence intervals, and effective sample sizes for the residual variances.
\item Rterms Posterior modes and confidence intervals for the variance-covariance parameters of the residuals.
\item cstats Convergence diagnostics, including potential scale reduction factor (PSRF) and effective sample size.
\item cutpoints Cutpoints used for ordinal responses.
\item theta_scale Scale parameters for the random effects.
} based on method selected.
}
\description{
Modularized function to estimate generalized linear mixed models with flexible random effects structure and survey weights incorporating options for E-Step and M-Step.
}
\details{
For comparability between runs, set a seed due to stochastic optimization.
}
\examples{
\dontrun{
library(mvtnorm)
n <- 600              # Total population size per simulation
K <- 50               # Number of simulations
beta <- c(4, -2, -1)
covmat <- matrix(0.5, ncol = 2, nrow = 2)
diag(covmat) <- c(0.7, 1.3)
g1 <- 20              # Number of domains for d1
g2 <- 30              # Number of domains for d2

# Preallocate storage for simulation results
population_data <- vector("list", K)
sampled_data_uninformative <- vector("list", K)
sampled_data_informative <- vector("list", K)

# Perform simulations
for (k in 1:K) {
  X1           <- rnorm(n, mean = 2)
  X2           <- rexp(n, rate = 1)

  group1 <- rep(1:g1, length.out = n)
  group2 <- rep(1:g2, length.out = n)
  re1    <- rnorm(g1, sd = 2)
  re2    <- rmvnorm(g2, sigma = covmat)

  modX  <- model.matrix( ~ X1 + X2)
  modZ1 <- model.matrix( ~ -1 + as.factor(group1))
  modZ2A <- model.matrix( ~ -1 + as.factor(group2))
  modZ2B <- model.matrix( ~ -1 + X1:as.factor(group2))

  eta    <- modX \%*\% beta + modZ1 \%*\% re1 +
    modZ2A \%*\% as.vector(re2[,1]) +
    modZ2B \%*\% as.vector(re2[,2])

  lin <- eta + rnorm(n, sd = 2.3)
  prob <- 1 / (1 + exp(-eta))
  bin <- rbinom(n, size = 1, prob = prob)

dfsamp <- data.frame(group1 = group1, group2 = group2, X1 = X1, X2 = X2, lin = lin, bin = bin, eta = eta)
  population_data[[k]] <- dfsamp
}

# Step 2: Sampling
for (k in 1:K) {
  data_k <- population_data[[k]]

  # Non-informative sampling
  sampled_data_uninformative[[k]] <- do.call("rbind", lapply(split(data_k, data_k$group1), function(df) {
    probs <- df$X2 / sum(df$X2)

    sampled_indices <- sample(nrow(df), 5, replace = FALSE, prob = probs)
    sampled_df <- df[sampled_indices, ]

    sampled_df$inclusion_prob <- probs[sampled_indices]
    sampled_df$weights <- 1 / sampled_df$inclusion_prob

    return(sampled_df)
  }))

  out <- wglmm( lin ~ X1 + X2 + (1|group1) + (1+X1|group2),
              data = subset(sampled_data_uninformative[[k]], select = -c(inclusion_prob, weights)), trace = TRUE, iter1 = 250,
              iter2 = 1001, MI = 2000, family = gaussian(), e_step_method = "e_step_importance_sampling", weights = sampled_data_uninformative[[k]]$weights)


  # Informative sampling
  sampled_data_informative[[k]] <- do.call("rbind", lapply(split(data_k, data_k$group1), function(df) {
    residuals <- abs(df$lin - df$eta)

    quantiles <- quantile(residuals, probs = c(0.25, 0.5, 0.75))

    probs <- ifelse(residuals <= quantiles[1], 0.1,
                    ifelse(residuals <= quantiles[2], 0.2, 0.4))

    sampled_indices <- sample(nrow(df), 5, replace = FALSE, prob = probs)
    sampled_df <- df[sampled_indices, ]

    sampled_df$inclusion_prob <- probs[sampled_indices] * (5/30)
    sampled_df$weights <- 1 / sampled_df$inclusion_prob

    return(sampled_df)
  }))

  out <- wglmm( lin ~ X1 + X2 + (1|group1) + (1+X1|group2),
              data = subset(sampled_data_informative[[k]], select = -c(inclusion_prob, weights)), trace = TRUE, iter1 = 250,
              iter2 = 1001, MI = 2000, family = gaussian(), e_step_method = "e_step_importance_sampling", weights = sampled_data_informative[[k]]$weights)

}
}
}
\references{
Burgard, Jan Pablo and Doerr, Patricia (2018). Survey-weighted Generalized Linear Mixed Models. Trier University. Working Paper.
}
